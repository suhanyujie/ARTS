## 正文
### Algorithm
#### 算法题
>来自领扣 https://leetcode-cn.com/problems/palindrome-number/

* 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

#### 题解
* 看完题目，初步的想法是将数值转为字符串，对比第 1 位的和第 n 位的值是否一致。
* 官方题解：

```
思路

映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。

第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。
但是，如果反转后的数字大于 \text{int.MAX}int.MAX，我们将遇到整数溢出问题。

按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 \text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。

例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。

让我们看看如何将这个想法转化为一个算法。

算法

首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。

现在，让我们来考虑如何反转后半部分的数字。
对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。

现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？

我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。

作者：LeetCode
链接：https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

* 初读，发现还是没能直接理解。于是结合代码来看。由于我是用 Rust 实现的，领扣官方使用的是 C#。对着代码看了几遍，有些理解了。着手将其翻译成 Rust：

```rust
pub fn is_palindrome(x: i32) -> bool {
    let mut x: i32 = x;
    if x < 0 || (x!=0 && x % 10 == 0) {
        return false;
    }
    let mut revertedNumber: i32 = 0;
    while x > revertedNumber {
        revertedNumber = revertedNumber*10 + x%10;
        x /= 10;
    }
    x == revertedNumber || x == revertedNumber/10
}
```

* 与此同时，写了几个 test case。最终测试也是 ok。
* 完整代码参考 [Github 仓库](https://github.com/suhanyujie/leetcode-rust/tree/master/src/_6_palindrome-number)。

### Review
* 略

### Tip
* PHP 的 laravel 框架中，有一套非常好用的数组操作函数 `collect`。那么脱离了 laravel 还能用 collect 系列函数吗？答案是可以的，可以以扩展的方式使用 collect 系列函数。详情参考 https://www.php.net/manual/en/book.ds.php

### Share
* 文章 [熵：宇宙的终极规则，或许真能改变你的世界观？](http://www.ruanyifeng.com/blog/2017/04/entropy.html)
* 这是来自公司后端团队 `朱孟*` 的 ARTS 分享中的文章。读完之后，受益匪浅。自然界的万事万物似乎都蕴含着简单而又复杂的真理。“熵”也是其中之一。这个看似简单的规则，发现可以套用在工作生活中的很多例子上。比如：公司的发展。随着公司规模扩大，需要投入更多的精力和时间用于管理。因为人越多，“熵”越大。具体表现在，管理混乱、员工上班摸鱼，而因为人多，管理者没有好的办法兼顾到每一个员工。上一家公司是一家电商公司，由于业务的门槛，以及团队扩大，慢慢地发展为独角兽，公司人数在不到1年的时间里，从200多急速扩张到超过5百人。可是人数多了，管理混乱的弊端立即显现出来，公司大肆招募有经验的管理者，对老员工疏于管理和关心，导致老员工慢慢流失，管理混乱导致公司资金使用不合理，就这样，不到一年，公司慢慢走下坡路，已然出现融资难的问题，随后再进行裁员（我不是被裁的）。跟之前同事聊天，听到的都是公司裁员、公司快要运作不下去了、福利越来越差等信息。虽然身在新公司，但我也难免为其扼腕叹息。我觉得出现这种情况，主要责任还是公司领导层的问题。只是拼命发展业务，并没有提升服务；拼命扩大公司规模，却没有好的管理措施和方案。当然，也许领导有领导的苦衷，身为一线员工，我可能没有感受到。但我想表达的是，随着公司规模的扩大，对公司的管理和业务发展需要**越来越多**的精力和成本，如果没有准备好这些，就贸然扩大公司规模，肯定会让公司蒙受很大的损失。

## 参考
* https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode/
